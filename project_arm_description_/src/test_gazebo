#!/usr/bin/env python3

import rospy
import numpy as np
from scipy.interpolate import CubicSpline
from std_msgs.msg import Float64

def generate_spline_trajectory(start_q, end_q, num_points=100):
    #Genera una trayectoria suave usando splines c√∫bicos
    t = np.linspace(0, 1, num_points + 1)
    trajectory = []
    for i in range(len(start_q)):
        cs = CubicSpline([0, 1], [start_q[i], end_q[i]], bc_type='clamped')
        trajectory.append(cs(t))
    return np.array(trajectory).T

def publish_joint_positions():
    rospy.init_node('joint_position_publisher', anonymous=True)
    
    joint_pubs = [
        rospy.Publisher('/project_arm/joint_1_position_controller/command', Float64, queue_size=10),
        rospy.Publisher('/project_arm/joint_2_position_controller/command', Float64, queue_size=10),
        rospy.Publisher('/project_arm/joint_3_position_controller/command', Float64, queue_size=10),
        rospy.Publisher('/project_arm/joint_4_position_controller/command', Float64, queue_size=10),
        rospy.Publisher('/project_arm/joint_5_position_controller/command', Float64, queue_size=10),
        rospy.Publisher('/project_arm/joint_6_position_controller/command', Float64, queue_size=10),
        rospy.Publisher('/project_arm/joint_7_position_controller/command', Float64, queue_size=10),
    ]
    
    rate = rospy.Rate(10)  # 10 Hz

    # Posiciones inicial y final
    start_q = np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
    end_q = np.array([1.84, -0.04, -0.32, 1.84, -0.80, 2.17, 0.04])

    # Generar la trayectoria suave
    trajectory = generate_spline_trajectory(start_q, end_q)

    # Publicar la trayectoria
    for point in trajectory:
        for i, joint_pub in enumerate(joint_pubs):
            joint_position = Float64()
            joint_position.data = point[i]
            joint_pub.publish(joint_position)
        rate.sleep()

if __name__ == '__main__':
    try:
        publish_joint_positions()
    except rospy.ROSInterruptException:
        pass
